# -*- coding: utf-8 -*-
"""protfolio.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EqPsqg_MTYZSbLHmjBC1Cputr-gFAPZa
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestRegressor
from scipy.optimize import minimize

from google.colab import files
up=files.upload()

# Load the uploaded file
file_path = "example_holdings.csv"
df = pd.read_csv(file_path)

# Display the first few rows of the dataset
df.head()

df.isnull().sum()

df.info()

df.describe()

# Calculate total portfolio value
df["market_value"] = df["shares"] * df["price"]
total_portfolio_value = df["market_value"].sum()

# Calculate current weight of each asset in the portfolio
df["current_weight"] = (df["market_value"] / total_portfolio_value) * 100

# Compare current vs target weight to determine rebalancing needs
df["rebalance_needed"] = df["target_weight"] - df["current_weight"]

# Display the updated dataframe
df[["ticker", "security_name", "shares", "price", "market_value", "current_weight", "target_weight", "rebalance_needed"]]

import matplotlib.pyplot as plt

# Pie chart for current allocation
plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.pie(df["current_weight"], labels=df["ticker"], autopct='%1.1f%%', startangle=140)
plt.title("Current Portfolio Allocation")

# Pie chart for target allocation
plt.subplot(1, 2, 2)
plt.pie(df["target_weight"], labels=df["ticker"], autopct='%1.1f%%', startangle=140)
plt.title("Target Portfolio Allocation")

plt.show()

# Generate synthetic historical prices (100 days)
np.random.seed(42)
n_days = 100
tickers = df['ticker'].unique()
historical_prices = {ticker: np.cumprod(1 + np.random.normal(0, 0.01, n_days)) * df[df['ticker'] == ticker]['price'].values[0] for ticker in tickers}

# Convert to DataFrame
price_df = pd.DataFrame(historical_prices)
returns_df = price_df.pct_change().dropna()

# Feature Engineering: Calculate volatility and mean return
features = pd.DataFrame()
features['mean_return'] = returns_df.mean()
features['volatility'] = returns_df.std()

# Train ML Model (Random Forest) to predict asset weights
X = features[['mean_return', 'volatility']]
y = df.set_index('ticker')['target_weight']
model = RandomForestRegressor()
model.fit(X, y)
predicted_weights = model.predict(X)

# Portfolio Optimization using Markowitz (Minimum Variance)
def portfolio_volatility(weights, cov_matrix):
    return np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))

# Constraint: Weights sum to 1
constraints = ({'type': 'eq', 'fun': lambda w: np.sum(w) - 1})

# Bounds: No short selling (weights between 0 and 1)
bounds = [(0, 1) for _ in range(len(tickers))]

# Optimize weights
cov_matrix = returns_df.cov()
init_guess = np.array([1/len(tickers)] * len(tickers))
optimized_result = minimize(portfolio_volatility, init_guess, args=(cov_matrix,), method='SLSQP', bounds=bounds, constraints=constraints)
optimized_weights = optimized_result.x

# Visualize rebalanced portfolio
plt.figure(figsize=(8, 5))
plt.bar(tickers, optimized_weights * 100, label='Optimized Weights')
plt.bar(tickers, predicted_weights, alpha=0.5, label='Predicted Weights')
plt.xlabel("Ticker")
plt.ylabel("Weight (%)")
plt.legend()
plt.title("Portfolio Rebalancing: ML vs Optimization")
plt.show()

# Display final rebalanced weights
final_weights = pd.DataFrame({'Ticker': tickers, 'Optimized Weight': optimized_weights * 100, 'Predicted Weight': predicted_weights})
print(final_weights)

"https://www.youtube.com/watch?v=wYAdztqymh4"